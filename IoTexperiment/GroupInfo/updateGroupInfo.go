package main

import (
	"crypto/ecdsa"
	"crypto/elliptic"
	"crypto/sha1"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"math/big"
	"sync"
	"github.com/hyperledger/fabric/core/chaincode/shim"
	"github.com/hyperledger/fabric/protos/peer"
	"time"
)

// Define the Smart Contract structure
type SmartContract struct {
}

type GroupInfo struct {
	// The list of registered devices in the identity group （key: device hash, value: timestamp）
	GroupList sync.Map `json:"groupList"`
	// The public parameter of identity group
	PublicParameter string `json:"publicParameter"`
	// The hash of device's abe master key which is used to identify authority of accessing updateGroupInfo
	MasterKeyHash string `json:"masterKeyHash"`
}

type jsonType struct {
	MP map[string]string
	PP string
	MS string
}

// Define the Registration structure, with 6 properties.  Structure tags are used by encoding/json library
type Registration struct {
	// Device Unique ID (adopt hash function to hash device's certificate)
	Uid  string `json:"uid"`
	// The hexString of device owner's ECDSA public key
	DeviceOwnerPriHex  string `json:"deviceOwnerPriHex"`
	// The signature of device certificate which is signed by device owner ECDSA public key and using ECDSA algorithm
	RText string `json:"rText"`
	// The signature of device certificate which is signed by device owner ECDSA public key and using ECDSA algorithm
	SText string `json:"sText"`
	// The certificate of device generated by device owner using the csr file which generated by device.
	DeviceCert string `json:"deviceCert"`
	// The ECDH public key of device which is used to create share secret key adopted by ECDH encryption
	DeviceEcdhPub string `json:"deviceEcdhPub"`
	//The time constrain of device's CPABE key
	KeyValidTimeStamp string `json:"keyValidTimeStamp"`
}


func (s *SmartContract) Init(APIstub shim.ChaincodeStubInterface) peer.Response {
	groupID := "test"
	groupInfo := new(GroupInfo)

	groupInfo.GroupList.Store("yjs-test", "testing")
	groupInfo.PublicParameter = "test"
	groupInfo.MasterKeyHash = "test123"
	groupInfoBytes,err := MarshalJSON(groupInfo)
	if err != nil {
		return shim.Error("can not json data")
	}
	APIstub.PutState(groupID, groupInfoBytes)
	fmt.Println("groupInfo length", len(groupInfoBytes))
	return shim.Success([]byte(groupID))
}


func (s *SmartContract) Invoke(APIstub shim.ChaincodeStubInterface) peer.Response {

	// Retrieve the requested Smart Contract function and arguments
	function, args := APIstub.GetFunctionAndParameters()

	if function == "verifyDeviceQueryGroupInfo" {
		return s.verifyDeviceQueryGroupInfo(APIstub, args)
	} else if function == "updateGroupInfoByDeviceHash" {
		return s.updateGroupInfoByDeviceHash(APIstub, args)
	} else if function == "updateGroupInfoByPubParameter"{
		return s.updateGroupInfoByPubParameter(APIstub, args)
	} else if function == "createGroupInfo"{
		return s.createGroupInfo(APIstub, args)
	} else if function == "queryGroupInfoTest" {
		return s.queryGroupInfoTest(APIstub, args)
	}
	return shim.Error("Invalid Smart Contract function name.")
}

//创建身份组信息
// Args： 1。身份组ID  2。身份组的Public Parameter  3。身份组的Master Key Hash
func (s *SmartContract) createGroupInfo(APIstub shim.ChaincodeStubInterface, args []string) peer.Response {
	if len(args) != 3 {
		return shim.Error("Incorrect number of arguments. Expecting 3")
	}
	groupID := args[0]
	//创建新的身份组信息
	groupInfo := new(GroupInfo)
	groupInfo.GroupList.Store("default", "default")
	groupInfo.PublicParameter = args[1]
	groupInfo.MasterKeyHash = args[2]
	groupInfoBytes,err := MarshalJSON(groupInfo)
	if err != nil {
		return shim.Error("can not json data")
	}
	APIstub.PutState(groupID, groupInfoBytes)
	return shim.Success([]byte(groupID))
}

//根据groupID查询对应的身份组信息
func (s *SmartContract) queryGroupInfoTest(APIstub shim.ChaincodeStubInterface, args []string) peer.Response {
	if len(args) != 2 {
		return shim.Error("Incorrect number of arguments. Expecting 2")
	}
	groupInfoBytes, _ := APIstub.GetState(args[0])
	group,error := UnmarshalJSON(groupInfoBytes)
	if error != nil {
		return shim.Error("jason type is wrong")
	}
	value,_ := group.GroupList.Load(args[1])
	fmt.Println(value)
	return shim.Success([]byte(value.(string)))
}


//只有拥有正确的master key hash的用户才能调用这个方法来添加设备到自己的身份组中， args： 1。身份组的ID 2。master key的hash值 3。设备的证书
func (s *SmartContract) updateGroupInfoByDeviceHash(APIstub shim.ChaincodeStubInterface, args []string) peer.Response {
	if len(args) != 3 {
		return shim.Error("Incorrect number of arguments. Expecting 1")
	}
	//根据组ID来查询对应的组信息
	groupInfoBytes, _ := APIstub.GetState(args[0])
	group,error := UnmarshalJSON(groupInfoBytes)
	if error != nil {
		return shim.Error("jason type is wrong")
	}
	//判断用户提交的master key hash与身份组的master hash是否匹配
	if group.MasterKeyHash != args[1] {
		return shim.Error("User can not access identity info since user's master key hash is mismatch")
	}

	//判断设备的身份是否有效
	deviceCertHash := SHA256(args[2])
	registrationAsBytes := APIstub.GetState(deviceCertHash)
	if registrationAsBytes == nil{
		return shim.Error("The device's info which query by deviceCert does not exist")
	}
	res := new(Registration)
	err := json.Unmarshal(registrationAsBytes,&res)
	if err != nil{
		return shim.Error("jason type is wrong")
	}
	result,deviceEcdhPubKey := verifyDeviceIdentity(res)
	if !result && deviceEcdhPubKey == "" {
		return shim.Error("Device verification is failure")
	}

	//存入设备的hash值（作为key），用什么做hash值呢？ 可以将timestamp作为value
	currentTime := time.Now().Format("2006-01-02 15:04:05 MST Mon")
	_,trueOrFalse :=group.GroupList.LoadOrStore(deviceCertHash, currentTime)
	if trueOrFalse {
		return shim.Error("The deviceCertHash has already existed")
	}
	//更新组信息
	groupInfoBytesNew,err := MarshalJSON(group)
	if err != nil {
		return shim.Error("jason type is wrong")
	}
	APIstub.PutState(args[0], groupInfoBytesNew)
	//返回ECDH public key给group owner用来加密cpabe key
	return shim.Success([]byte(deviceEcdhPubKey))
}


//只有拥有正确的master key hash的用户才能更改身份组中的public parameter。
//args: 1。身份组ID 2。User's master key hash 3。待更新的public parameter
func (s *SmartContract) updateGroupInfoByPubParameter(APIstub shim.ChaincodeStubInterface, args []string) peer.Response {
	if len(args) != 3 {
		return shim.Error("Incorrect number of arguments. Expecting 3")
	}
	//根据组ID来查询对应的组信息
	groupInfoBytes, _ := APIstub.GetState(args[0])
	group,error := UnmarshalJSON(groupInfoBytes)
	if error != nil {
		return shim.Error("jason type is wrong")
	}

	//判断用户的Master key hash是否正确
	if group.MasterKeyHash != args[1]{
		return shim.Error("User can not access identity info since user's master key hash is mismatch")
	}
	//更新public parameter
	group.PublicParameter = args[2]
	groupInfoBytesNew,err := MarshalJSON(group)
	if err != nil {
		return shim.Error("jason type is wrong")
	}
	//更新组信息
	APIstub.PutState(args[0], groupInfoBytesNew)
	return shim.Success([]byte(args[1]))
}

//根据用户提供的设备证书hash值来判断是否存在group list中，若存在，则该publisher设备是有效的，可以进行跨组通信（获取目标身份组中的public parameter）
// Args： 1。publisher device的身份组ID  2。publisher device cert hash  3。目标身份组ID
func (s *SmartContract) verifyDeviceQueryGroupInfo(APIstub shim.ChaincodeStubInterface, args []string) peer.Response {

	if len(args) != 3 {
		return shim.Error("Incorrect number of arguments. Expecting 1")
	}

	//先验证消息发送者的身份，根据消息发送者所处的身份组ID查询身份组信息
	pubGroupInfoBytes,_ := APIstub.GetState(args[0])
	pubGroup,pubError := UnmarshalJSON(pubGroupInfoBytes)
	if pubError != nil {
		return shim.Error("jason type is wrong")
	}
	_,pubResult := pubGroup.GroupList.Load(args[1])
	//消息发送者设备的证书hash存在于该身份组中
	if pubResult {
		//根据目标组ID来查询对应的组信息
		subGroupInfoBytes, _ := APIstub.GetState(args[2])
		subGroup,subError := UnmarshalJSON(subGroupInfoBytes)
		if subError != nil {
			return shim.Error("jason type is wrong")
		}
		////根据设备的hash值查询是否存在于这个身份组中
		//_,subResult := subGroup.GroupList.Load(args[1])
		//if !subResult {
		//	return shim.Error("specific device does not exist in this identity group")
		//}
		return shim.Success([]byte(subGroup.PublicParameter))
	}
	return shim.Error("Verification is failure")
}

func verifyDeviceIdentity(res *Registration) (bool,string) {

	priv := hexToPrivateKey(res.DeviceOwnerPriHex)
	ePub := priv.Public().(*ecdsa.PublicKey)
	result := verifyMySig(ePub, res.DeviceCert, res.RText, res.SText)
	//若验证通过，则返回设备的ECDH public key
	var deviceEcdhPubKey string
	if result {
		deviceEcdhPubKey = res.DeviceEcdhPub
	} else {
		deviceEcdhPubKey = ""
	}
	return result,deviceEcdhPubKey

}

func verifyMySig(pub *ecdsa.PublicKey, msg string, rText, sText string) bool {
	//https://github.com/gtank/cryptopasta
	digest := sha1.Sum([]byte(msg))

	//var esig crypto.ECDSASig
	////asn1.Unmarshal(sig, &esig)
	////above is ASN1 decoding from the Java format. Alternatively, we can just transfer R and S parameters and set those
	// esig.R.SetString(rText, 0)
	// esig.S.SetString(sText, 0)
	R,_ := new(big.Int).SetString(rText,10)
	S,_ := new(big.Int).SetString(sText,10)
	//fmt.Printf("R: %d , S: %d", R, S)
	println()
	return ecdsa.Verify(pub, digest[:], R, S)
}

func hexToPrivateKey(hexStr string)  *ecdsa.PrivateKey {
	bytes, err := hex.DecodeString(hexStr)
	print(err)

	k := new(big.Int)
	k.SetBytes(bytes)
	//println("k:")
	//fmt.Println(k.String())

	priv := new(ecdsa.PrivateKey)
	curve := elliptic.P256()
	priv.PublicKey.Curve = curve
	priv.D = k
	priv.PublicKey.X, priv.PublicKey.Y = curve.ScalarBaseMult(k.Bytes())
	//we can check these against the Java implementation to see if it matches to know key was transferred OK
	//fmt.Printf("X: %d, Y: %d", priv.PublicKey.X, priv.PublicKey.Y)
	//println()

	return priv
}

func MarshalJSON(m *GroupInfo) ([]byte, error) {
	tmp := new(jsonType)
	tmp.MP = make(map[string]string)
	m.GroupList.Range(func(k, v interface{}) bool {
		tmp.MP[k.(string)] = v.(string)
		return true
	})
	tmp.PP = m.PublicParameter
	tmp.MS = m.MasterKeyHash
	return json.Marshal(tmp)
}

func UnmarshalJSON(data []byte) (*GroupInfo, error) {
	tmp := new(jsonType)
	//var tmpMap map[string]interface{}
	m := new(GroupInfo)
	if err := json.Unmarshal(data, &tmp); err != nil {
		return m, err
	}
	for key, value := range tmp.MP {
		m.GroupList.Store(key, value)
	}
	m.PublicParameter = tmp.PP
	m.MasterKeyHash = tmp.MS
	return m, nil
}

// The main function is only relevant in unit test mode. Only included here for completeness.
func main() {

	// Create a new Smart Contract
	err := shim.Start(new(SmartContract))
	if err != nil {
		fmt.Printf("Error creating new Smart Contract: %s", err)
	}
}