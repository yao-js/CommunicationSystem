package main

import (
	"crypto/ecdsa"
	"crypto/elliptic"
	"crypto/sha1"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"math/big"
	"github.com/hyperledger/fabric/core/chaincode/shim"
	"github.com/hyperledger/fabric/protos/peer"
	"strconv"
)

// Define the Smart Contract structure
type SmartContract struct {
}

// Define the Registration structure, with 6 properties.  Structure tags are used by encoding/json library
type Registration struct {
	// Device Unique ID (adopt hash function to hash device's certificate)
	Uid  string `json:"uid"`
	// Device owner certificate which contains device owner certificate and other needed information
	DeviceOwnerPriHex  string `json:"deviceOwnerPriHex"`
	// The signature of device certificate which is signed by device owner ECDSA public key and using ECDSA algorithm
	RText string `json:"rText"`
	// The signature of device certificate which is signed by device owner ECDSA public key and using ECDSA algorithm
	SText string `json:"sText"`
	// The certificate of device generated by device owner using the csr file which generated by device.
	DeviceCert string `json:"deviceCert"`
	// The ECDH public key of device which is used to create share secret key adopted by ECDH encryption
	DeviceEcdhPub string `json:"deviceEcdhPub"`
	//The time constrain of device's CPABE key
	KeyValidTimeStamp string `json:"keyValidTimeStamp"`
}

func (s *SmartContract) Init(APIstub shim.ChaincodeStubInterface) peer.Response {
	registrationHash := SHA256("test")
	regs := Registration{
		Uid:            "test",
		DeviceOwnerPriHex: "test",
		RText:       "test",
		SText:       "test",
		DeviceCert:      "test",
		DeviceEcdhPub:  "test",
		KeyValidTimeStamp:  "",
	}

	registrationAsBytes, _ := json.Marshal(regs)
	APIstub.PutState(registrationHash, registrationAsBytes)
	fmt.Println("Added", registrationAsBytes)
	//fmt.Println(registrationHash)
	return shim.Success([]byte(registrationHash))
}

func (s *SmartContract) Invoke(APIstub shim.ChaincodeStubInterface) peer.Response {

	// Retrieve the requested Smart Contract function and arguments
	function, args := APIstub.GetFunctionAndParameters()

	if function == "queryRegistration" {
		return s.queryRegistration(APIstub, args)
	} else if function == "createRegistration" {
		return s.createRegistration(APIstub, args)
	} else if function == "verifyDeviceIdentity"{
		return s.verifyDeviceIdentity(APIstub, args)
	}

	return shim.Error("Invalid Smart Contract function name.")
}


func (s *SmartContract) queryRegistration(APIstub shim.ChaincodeStubInterface, args []string) peer.Response {

	if len(args) != 1 {
		return shim.Error("Incorrect number of arguments. Expecting 1")
	}
	//根据设备证书的hash值来找相关信息
	registrationAsBytes, _ := APIstub.GetState(args[0])
	return shim.Success(registrationAsBytes)
}

//func (s *SmartContract) addTimeStamp(APIstub shim.ChaincodeStubInterface, args []string) peer.Response{
//	if len(args) != 2 {
//		return shim.Error("Incorrect number of arguments. Expecting 2")
//	}
//	deviceCertHash := args[0]
//	registrationAsBytes, _ := APIstub.GetState(deviceCertHash)
//	if registrationAsBytes == nil{
//		return shim.Error("The device's info which query by deviceCert does not exist")
//	}
//	res := new(Registration)
//	err := json.Unmarshal(registrationAsBytes,&res)
//	if err != nil{
//		return shim.Error("jason type is wrong")
//	}
//	res.KeyValidTimeStamp = args[1]
//	registerAsBytes, _ := json.Marshal(res)
//	APIstub.PutState(deviceCertHash, registerAsBytes)
//	return shim.Success([]byte(deviceCertHash))
//}
//
//func (s *SmartContract) verifyTimeStamp(APIstub shim.ChaincodeStubInterface, args []string) peer.Response {
//	if len(args) != 2 {
//		return shim.Error("Incorrect number of arguments. Expecting 2")
//	}
//	deviceCertHash := args[0]
//	//根据设备的hash值获取设备的注册信息
//	registrationAsBytes, _ := APIstub.GetState(deviceCertHash)
//	if registrationAsBytes == nil{
//		return shim.Error("The device's info which query by deviceCert does not exist")
//	}
//	res := new(Registration)
//	err := json.Unmarshal(registrationAsBytes,&res)
//	if err != nil{
//		return shim.Error("jason type is wrong")
//	}
//	//根据之前存入fabric账本中的有效时间戳信息，判断当前的时间戳是否满足这个有效时间戳
//	validTimeStamp,_ := time.Parse("2006-01-02 15:04:05", res.KeyValidTimeStamp)
//	currentTimeStamp,_ := time.Parse("2006-01-02 15:04:05", args[1])
//	trueOrFalse := currentTimeStamp.After(validTimeStamp)
//	//返回的bool值如果是true的话则是当前时间戳是在有效时间戳之后，如果是false的话则是在有效时间戳之前
//	str := strconv.FormatBool(trueOrFalse)
//	return shim.Success([]byte(str))
//}

func (s *SmartContract) createRegistration(APIstub shim.ChaincodeStubInterface, args []string) peer.Response {

	if len(args) != 6 {
		return shim.Error("Incorrect number of arguments. Expecting 5")
	}

	//对设备的证书生成唯一的hash值作为唯一标示
	registrationHash := SHA256(args[4])
	var regsiter = Registration{
		Uid:            args[0],
		DeviceOwnerPriHex: args[1],
		RText:       args[2],
		SText:       args[3],
		DeviceCert:      args[4],
		DeviceEcdhPub:  args[5],

	}

	//根据设备证书hash值查找是否以及存在对应的信息
	deviceAsBytes, _ := APIstub.GetState(registrationHash)
	if deviceAsBytes != nil{
		return shim.Error("The device ID has already existed, please check it out")
	}

	//如不存在则添加到blockchian中
	registerAsBytes, _ := json.Marshal(regsiter)
	APIstub.PutState(registrationHash, registerAsBytes)
	fmt.Println(registerAsBytes)
	//fmt.Println(registrationHash)
	return shim.Success([]byte(registrationHash))
}

func (s *SmartContract) verifyDeviceIdentity(APIstub shim.ChaincodeStubInterface, args []string) peer.Response {

	if len(args) != 1 {
		return shim.Error("Incorrect number of arguments. Expecting 1")
	}
	//根据设备证书的hash值来找相关信息
	registrationAsBytes, _ := APIstub.GetState(args[0])
	if registrationAsBytes == nil{
		return shim.Error("The device's info which query by deviceCert does not exist")
	}
	res := new(Registration)
	err := json.Unmarshal(registrationAsBytes,&res)
	if err != nil{
		return shim.Error("jason type is wrong")
	}
	priv := hexToPrivateKey(res.DeviceOwnerPriHex)
	ePub := priv.Public().(*ecdsa.PublicKey)
	result := verifyMySig(ePub, res.DeviceCert, res.RText, res.SText)
	str := strconv.FormatBool(result)

	return shim.Success([]byte(str))

}

func verifyMySig(pub *ecdsa.PublicKey, msg string, rText, sText string) bool {
	//https://github.com/gtank/cryptopasta
	digest := sha1.Sum([]byte(msg))

	//var esig crypto.ECDSASig
	////asn1.Unmarshal(sig, &esig)
	////above is ASN1 decoding from the Java format. Alternatively, we can just transfer R and S parameters and set those
	// esig.R.SetString(rText, 0)
	// esig.S.SetString(sText, 0)
	R,_ := new(big.Int).SetString(rText,10)
	S,_ := new(big.Int).SetString(sText,10)
	//fmt.Printf("R: %d , S: %d", R, S)
	println()
	return ecdsa.Verify(pub, digest[:], R, S)
}

func hexToPrivateKey(hexStr string)  *ecdsa.PrivateKey {
	bytes, err := hex.DecodeString(hexStr)
	print(err)

	k := new(big.Int)
	k.SetBytes(bytes)
	//println("k:")
	//fmt.Println(k.String())

	priv := new(ecdsa.PrivateKey)
	curve := elliptic.P256()
	priv.PublicKey.Curve = curve
	priv.D = k
	priv.PublicKey.X, priv.PublicKey.Y = curve.ScalarBaseMult(k.Bytes())
	//we can check these against the Java implementation to see if it matches to know key was transferred OK
	//fmt.Printf("X: %d, Y: %d", priv.PublicKey.X, priv.PublicKey.Y)
	//println()

	return priv
}


// The main function is only relevant in unit test mode. Only included here for completeness.
func main() {

	// Create a new Smart Contract
	err := shim.Start(new(SmartContract))
	if err != nil {
		fmt.Printf("Error creating new Smart Contract: %s", err)
	}
}